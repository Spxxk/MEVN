{"ast":null,"code":"/*\n\nCopied from https://github.com/mathiasbynens/punycode.js/blob/ef3505c8abb5143a00d53ce59077c9f7f4b2ac47/punycode.js\n\nCopyright Mathias Bynens <https://mathiasbynens.be/>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n/* eslint callback-return: 0, no-bitwise: 0, eqeqeq: 0, prefer-arrow-callback: 0, object-shorthand: 0 */\n\n'use strict';\n\n/** Highest positive signed 32-bit float value */\nrequire(\"core-js/modules/es.array.push.js\");\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n  overflow: 'Overflow: input needs wider integers to process',\n  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n  'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n  throw new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n  const result = [];\n  let length = array.length;\n  while (length--) {\n    result[length] = callback(array[length]);\n  }\n  return result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n  const parts = domain.split('@');\n  let result = '';\n  if (parts.length > 1) {\n    // In email addresses, only the domain name should be punycoded. Leave\n    // the local part (i.e. everything up to `@`) intact.\n    result = parts[0] + '@';\n    domain = parts[1];\n  }\n  // Avoid `split(regex)` for IE8 compatibility. See #17.\n  domain = domain.replace(regexSeparators, '\\x2E');\n  const labels = domain.split('.');\n  const encoded = map(labels, callback).join('.');\n  return result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n    if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      const extra = string.charCodeAt(counter++);\n      if ((extra & 0xfc00) == 0xdc00) {\n        // Low surrogate.\n        output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function (codePoint) {\n  if (codePoint >= 0x30 && codePoint < 0x3a) {\n    return 26 + (codePoint - 0x30);\n  }\n  if (codePoint >= 0x41 && codePoint < 0x5b) {\n    return codePoint - 0x41;\n  }\n  if (codePoint >= 0x61 && codePoint < 0x7b) {\n    return codePoint - 0x61;\n  }\n  return base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function (digit, flag) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function (delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n  for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function (input) {\n  // Don't use UCS-2.\n  const output = [];\n  const inputLength = input.length;\n  let i = 0;\n  let n = initialN;\n  let bias = initialBias;\n\n  // Handle the basic code points: let `basic` be the number of input code\n  // points before the last delimiter, or `0` if there is none, then copy\n  // the first basic code points to the output.\n\n  let basic = input.lastIndexOf(delimiter);\n  if (basic < 0) {\n    basic = 0;\n  }\n  for (let j = 0; j < basic; ++j) {\n    // if it's not a basic code point\n    if (input.charCodeAt(j) >= 0x80) {\n      error('not-basic');\n    }\n    output.push(input.charCodeAt(j));\n  }\n\n  // Main decoding loop: start just after the last delimiter if any basic code\n  // points were copied; start at the beginning otherwise.\n\n  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */;) {\n    // `index` is the index of the next character to be consumed.\n    // Decode a generalized variable-length integer into `delta`,\n    // which gets added to `i`. The overflow checking is easier\n    // if we increase `i` as we go, then subtract off its starting\n    // value at the end to obtain `delta`.\n    const oldi = i;\n    for (let w = 1, k = base /* no condition */;; k += base) {\n      if (index >= inputLength) {\n        error('invalid-input');\n      }\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base) {\n        error('invalid-input');\n      }\n      if (digit > floor((maxInt - i) / w)) {\n        error('overflow');\n      }\n      i += digit * w;\n      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n      if (digit < t) {\n        break;\n      }\n      const baseMinusT = base - t;\n      if (w > floor(maxInt / baseMinusT)) {\n        error('overflow');\n      }\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    bias = adapt(i - oldi, out, oldi == 0);\n\n    // `i` was supposed to wrap around from `out` to `0`,\n    // incrementing `n` each time, so we'll fix that now:\n    if (floor(i / out) > maxInt - n) {\n      error('overflow');\n    }\n    n += floor(i / out);\n    i %= out;\n\n    // Insert `n` at position `i` of the output.\n    output.splice(i++, 0, n);\n  }\n  return String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function (input) {\n  const output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  const inputLength = input.length;\n\n  // Initialize the state.\n  let n = initialN;\n  let delta = 0;\n  let bias = initialBias;\n\n  // Handle the basic code points.\n  for (const currentValue of input) {\n    if (currentValue < 0x80) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n  const basicLength = output.length;\n  let handledCPCount = basicLength;\n\n  // `handledCPCount` is the number of code points that have been handled;\n  // `basicLength` is the number of basic code points.\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    output.push(delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next\n    // larger one:\n    let m = maxInt;\n    for (const currentValue of input) {\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n    // but guard against overflow.\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      error('overflow');\n    }\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n    for (const currentValue of input) {\n      if (currentValue < n && ++delta > maxInt) {\n        error('overflow');\n      }\n      if (currentValue === n) {\n        // Represent delta as a generalized variable-length integer.\n        let q = delta;\n        for (let k = base /* no condition */;; k += base) {\n          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (q < t) {\n            break;\n          }\n          const qMinusT = q - t;\n          const baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n          q = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q, 0)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n    ++delta;\n    ++n;\n  }\n  return output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function (input) {\n  return mapDomain(input, function (string) {\n    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n  });\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function (input) {\n  return mapDomain(input, function (string) {\n    return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n  });\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n  /**\n   * A string representing the current Punycode.js version number.\n   * @memberOf punycode\n   * @type String\n   */\n  version: '2.3.1',\n  /**\n   * An object of methods to convert from JavaScript's internal character\n   * representation (UCS-2) to Unicode code points, and back.\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode\n   * @type Object\n   */\n  ucs2: {\n    decode: ucs2decode,\n    encode: ucs2encode\n  },\n  decode: decode,\n  encode: encode,\n  toASCII: toASCII,\n  toUnicode: toUnicode\n};\nmodule.exports = punycode;","map":{"version":3,"names":["require","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","overflow","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error","type","RangeError","map","array","callback","result","length","mapDomain","domain","parts","split","replace","labels","encoded","join","ucs2decode","string","output","counter","value","charCodeAt","extra","push","ucs2encode","codePoints","fromCodePoint","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","i","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","test","slice","toLowerCase","toASCII","punycode","version","ucs2","module","exports"],"sources":["C:/Users/jason/Desktop/owen/frontend/node_modules/nodemailer/lib/punycode/index.js"],"sourcesContent":["/*\n\nCopied from https://github.com/mathiasbynens/punycode.js/blob/ef3505c8abb5143a00d53ce59077c9f7f4b2ac47/punycode.js\n\nCopyright Mathias Bynens <https://mathiasbynens.be/>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n/* eslint callback-return: 0, no-bitwise: 0, eqeqeq: 0, prefer-arrow-callback: 0, object-shorthand: 0 */\n\n'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n    overflow: 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n    throw new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n    const result = [];\n    let length = array.length;\n    while (length--) {\n        result[length] = callback(array[length]);\n    }\n    return result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n    const parts = domain.split('@');\n    let result = '';\n    if (parts.length > 1) {\n        // In email addresses, only the domain name should be punycoded. Leave\n        // the local part (i.e. everything up to `@`) intact.\n        result = parts[0] + '@';\n        domain = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    domain = domain.replace(regexSeparators, '\\x2E');\n    const labels = domain.split('.');\n    const encoded = map(labels, callback).join('.');\n    return result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            } else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function (codePoint) {\n    if (codePoint >= 0x30 && codePoint < 0x3a) {\n        return 26 + (codePoint - 0x30);\n    }\n    if (codePoint >= 0x41 && codePoint < 0x5b) {\n        return codePoint - 0x41;\n    }\n    if (codePoint >= 0x61 && codePoint < 0x7b) {\n        return codePoint - 0x61;\n    }\n    return base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function (digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function (delta, numPoints, firstTime) {\n    let k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function (input) {\n    // Don't use UCS-2.\n    const output = [];\n    const inputLength = input.length;\n    let i = 0;\n    let n = initialN;\n    let bias = initialBias;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    let basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n\n    for (let j = 0; j < basic; ++j) {\n        // if it's not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n            error('not-basic');\n        }\n        output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */; ) {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        const oldi = i;\n        for (let w = 1, k = base /* no condition */; ; k += base) {\n            if (index >= inputLength) {\n                error('invalid-input');\n            }\n\n            const digit = basicToDigit(input.charCodeAt(index++));\n\n            if (digit >= base) {\n                error('invalid-input');\n            }\n            if (digit > floor((maxInt - i) / w)) {\n                error('overflow');\n            }\n\n            i += digit * w;\n            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n            if (digit < t) {\n                break;\n            }\n\n            const baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n                error('overflow');\n            }\n\n            w *= baseMinusT;\n        }\n\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n\n        // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we'll fix that now:\n        if (floor(i / out) > maxInt - n) {\n            error('overflow');\n        }\n\n        n += floor(i / out);\n        i %= out;\n\n        // Insert `n` at position `i` of the output.\n        output.splice(i++, 0, n);\n    }\n\n    return String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function (input) {\n    const output = [];\n\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    input = ucs2decode(input);\n\n    // Cache the length.\n    const inputLength = input.length;\n\n    // Initialize the state.\n    let n = initialN;\n    let delta = 0;\n    let bias = initialBias;\n\n    // Handle the basic code points.\n    for (const currentValue of input) {\n        if (currentValue < 0x80) {\n            output.push(stringFromCharCode(currentValue));\n        }\n    }\n\n    const basicLength = output.length;\n    let handledCPCount = basicLength;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n        output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        let m = maxInt;\n        for (const currentValue of input) {\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error('overflow');\n        }\n\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n\n        for (const currentValue of input) {\n            if (currentValue < n && ++delta > maxInt) {\n                error('overflow');\n            }\n            if (currentValue === n) {\n                // Represent delta as a generalized variable-length integer.\n                let q = delta;\n                for (let k = base /* no condition */; ; k += base) {\n                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    const qMinusT = q - t;\n                    const baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));\n                    q = floor(qMinusT / baseMinusT);\n                }\n\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n\n        ++delta;\n        ++n;\n    }\n    return output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function (input) {\n    return mapDomain(input, function (string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function (input) {\n    return mapDomain(input, function (string) {\n        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    version: '2.3.1',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    ucs2: {\n        decode: ucs2decode,\n        encode: ucs2encode\n    },\n    decode: decode,\n    encode: encode,\n    toASCII: toASCII,\n    toUnicode: toUnicode\n};\n\nmodule.exports = punycode;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AAAAA,OAAA;AACA,MAAMC,MAAM,GAAG,UAAU,CAAC,CAAC;;AAE3B;AACA,MAAMC,IAAI,GAAG,EAAE;AACf,MAAMC,IAAI,GAAG,CAAC;AACd,MAAMC,IAAI,GAAG,EAAE;AACf,MAAMC,IAAI,GAAG,EAAE;AACf,MAAMC,IAAI,GAAG,GAAG;AAChB,MAAMC,WAAW,GAAG,EAAE;AACtB,MAAMC,QAAQ,GAAG,GAAG,CAAC,CAAC;AACtB,MAAMC,SAAS,GAAG,GAAG,CAAC,CAAC;;AAEvB;AACA,MAAMC,aAAa,GAAG,OAAO;AAC7B,MAAMC,aAAa,GAAG,YAAY,CAAC,CAAC;AACpC,MAAMC,eAAe,GAAG,2BAA2B,CAAC,CAAC;;AAErD;AACA,MAAMC,MAAM,GAAG;EACXC,QAAQ,EAAE,iDAAiD;EAC3D,WAAW,EAAE,gDAAgD;EAC7D,eAAe,EAAE;AACrB,CAAC;;AAED;AACA,MAAMC,aAAa,GAAGb,IAAI,GAAGC,IAAI;AACjC,MAAMa,KAAK,GAAGC,IAAI,CAACD,KAAK;AACxB,MAAME,kBAAkB,GAAGC,MAAM,CAACC,YAAY;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACC,IAAI,EAAE;EACjB,MAAM,IAAIC,UAAU,CAACV,MAAM,CAACS,IAAI,CAAC,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,GAAGA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC1B,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,MAAM,GAAGH,KAAK,CAACG,MAAM;EACzB,OAAOA,MAAM,EAAE,EAAE;IACbD,MAAM,CAACC,MAAM,CAAC,GAAGF,QAAQ,CAACD,KAAK,CAACG,MAAM,CAAC,CAAC;EAC5C;EACA,OAAOD,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAACC,MAAM,EAAEJ,QAAQ,EAAE;EACjC,MAAMK,KAAK,GAAGD,MAAM,CAACE,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAIL,MAAM,GAAG,EAAE;EACf,IAAII,KAAK,CAACH,MAAM,GAAG,CAAC,EAAE;IAClB;IACA;IACAD,MAAM,GAAGI,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;IACvBD,MAAM,GAAGC,KAAK,CAAC,CAAC,CAAC;EACrB;EACA;EACAD,MAAM,GAAGA,MAAM,CAACG,OAAO,CAACrB,eAAe,EAAE,MAAM,CAAC;EAChD,MAAMsB,MAAM,GAAGJ,MAAM,CAACE,KAAK,CAAC,GAAG,CAAC;EAChC,MAAMG,OAAO,GAAGX,GAAG,CAACU,MAAM,EAAER,QAAQ,CAAC,CAACU,IAAI,CAAC,GAAG,CAAC;EAC/C,OAAOT,MAAM,GAAGQ,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,UAAUA,CAACC,MAAM,EAAE;EACxB,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMZ,MAAM,GAAGU,MAAM,CAACV,MAAM;EAC5B,OAAOY,OAAO,GAAGZ,MAAM,EAAE;IACrB,MAAMa,KAAK,GAAGH,MAAM,CAACI,UAAU,CAACF,OAAO,EAAE,CAAC;IAC1C,IAAIC,KAAK,IAAI,MAAM,IAAIA,KAAK,IAAI,MAAM,IAAID,OAAO,GAAGZ,MAAM,EAAE;MACxD;MACA,MAAMe,KAAK,GAAGL,MAAM,CAACI,UAAU,CAACF,OAAO,EAAE,CAAC;MAC1C,IAAI,CAACG,KAAK,GAAG,MAAM,KAAK,MAAM,EAAE;QAC5B;QACAJ,MAAM,CAACK,IAAI,CAAC,CAAC,CAACH,KAAK,GAAG,KAAK,KAAK,EAAE,KAAKE,KAAK,GAAG,KAAK,CAAC,GAAG,OAAO,CAAC;MACpE,CAAC,MAAM;QACH;QACA;QACAJ,MAAM,CAACK,IAAI,CAACH,KAAK,CAAC;QAClBD,OAAO,EAAE;MACb;IACJ,CAAC,MAAM;MACHD,MAAM,CAACK,IAAI,CAACH,KAAK,CAAC;IACtB;EACJ;EACA,OAAOF,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,UAAU,GAAGC,UAAU,IAAI3B,MAAM,CAAC4B,aAAa,CAAC,GAAGD,UAAU,CAAC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,YAAY,GAAG,SAAAA,CAAUC,SAAS,EAAE;EACtC,IAAIA,SAAS,IAAI,IAAI,IAAIA,SAAS,GAAG,IAAI,EAAE;IACvC,OAAO,EAAE,IAAIA,SAAS,GAAG,IAAI,CAAC;EAClC;EACA,IAAIA,SAAS,IAAI,IAAI,IAAIA,SAAS,GAAG,IAAI,EAAE;IACvC,OAAOA,SAAS,GAAG,IAAI;EAC3B;EACA,IAAIA,SAAS,IAAI,IAAI,IAAIA,SAAS,GAAG,IAAI,EAAE;IACvC,OAAOA,SAAS,GAAG,IAAI;EAC3B;EACA,OAAO/C,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgD,YAAY,GAAG,SAAAA,CAAUC,KAAK,EAAEC,IAAI,EAAE;EACxC;EACA;EACA,OAAOD,KAAK,GAAG,EAAE,GAAG,EAAE,IAAIA,KAAK,GAAG,EAAE,CAAC,IAAI,CAACC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,GAAG,SAAAA,CAAUC,KAAK,EAAEC,SAAS,EAAEC,SAAS,EAAE;EACjD,IAAIC,CAAC,GAAG,CAAC;EACTH,KAAK,GAAGE,SAAS,GAAGxC,KAAK,CAACsC,KAAK,GAAGhD,IAAI,CAAC,GAAGgD,KAAK,IAAI,CAAC;EACpDA,KAAK,IAAItC,KAAK,CAACsC,KAAK,GAAGC,SAAS,CAAC;EACjC,OAAO,uBAAwBD,KAAK,GAAIvC,aAAa,GAAGX,IAAI,IAAK,CAAC,EAAEqD,CAAC,IAAIvD,IAAI,EAAE;IAC3EoD,KAAK,GAAGtC,KAAK,CAACsC,KAAK,GAAGvC,aAAa,CAAC;EACxC;EACA,OAAOC,KAAK,CAACyC,CAAC,GAAI,CAAC1C,aAAa,GAAG,CAAC,IAAIuC,KAAK,IAAKA,KAAK,GAAGjD,IAAI,CAAC,CAAC;AACpE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMqD,MAAM,GAAG,SAAAA,CAAUC,KAAK,EAAE;EAC5B;EACA,MAAMpB,MAAM,GAAG,EAAE;EACjB,MAAMqB,WAAW,GAAGD,KAAK,CAAC/B,MAAM;EAChC,IAAIiC,CAAC,GAAG,CAAC;EACT,IAAIC,CAAC,GAAGtD,QAAQ;EAChB,IAAIuD,IAAI,GAAGxD,WAAW;;EAEtB;EACA;EACA;;EAEA,IAAIyD,KAAK,GAAGL,KAAK,CAACM,WAAW,CAACxD,SAAS,CAAC;EACxC,IAAIuD,KAAK,GAAG,CAAC,EAAE;IACXA,KAAK,GAAG,CAAC;EACb;EAEA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAE,EAAEE,CAAC,EAAE;IAC5B;IACA,IAAIP,KAAK,CAACjB,UAAU,CAACwB,CAAC,CAAC,IAAI,IAAI,EAAE;MAC7B7C,KAAK,CAAC,WAAW,CAAC;IACtB;IACAkB,MAAM,CAACK,IAAI,CAACe,KAAK,CAACjB,UAAU,CAACwB,CAAC,CAAC,CAAC;EACpC;;EAEA;EACA;;EAEA,KAAK,IAAIC,KAAK,GAAGH,KAAK,GAAG,CAAC,GAAGA,KAAK,GAAG,CAAC,GAAG,CAAC,EAAEG,KAAK,GAAGP,WAAW,CAAC,4BAA6B;IACzF;IACA;IACA;IACA;IACA;IACA,MAAMQ,IAAI,GAAGP,CAAC;IACd,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEZ,CAAC,GAAGvD,IAAI,CAAC,qBAAsBuD,CAAC,IAAIvD,IAAI,EAAE;MACtD,IAAIiE,KAAK,IAAIP,WAAW,EAAE;QACtBvC,KAAK,CAAC,eAAe,CAAC;MAC1B;MAEA,MAAM8B,KAAK,GAAGH,YAAY,CAACW,KAAK,CAACjB,UAAU,CAACyB,KAAK,EAAE,CAAC,CAAC;MAErD,IAAIhB,KAAK,IAAIjD,IAAI,EAAE;QACfmB,KAAK,CAAC,eAAe,CAAC;MAC1B;MACA,IAAI8B,KAAK,GAAGnC,KAAK,CAAC,CAACf,MAAM,GAAG4D,CAAC,IAAIQ,CAAC,CAAC,EAAE;QACjChD,KAAK,CAAC,UAAU,CAAC;MACrB;MAEAwC,CAAC,IAAIV,KAAK,GAAGkB,CAAC;MACd,MAAMC,CAAC,GAAGb,CAAC,IAAIM,IAAI,GAAG5D,IAAI,GAAGsD,CAAC,IAAIM,IAAI,GAAG3D,IAAI,GAAGA,IAAI,GAAGqD,CAAC,GAAGM,IAAI;MAE/D,IAAIZ,KAAK,GAAGmB,CAAC,EAAE;QACX;MACJ;MAEA,MAAMC,UAAU,GAAGrE,IAAI,GAAGoE,CAAC;MAC3B,IAAID,CAAC,GAAGrD,KAAK,CAACf,MAAM,GAAGsE,UAAU,CAAC,EAAE;QAChClD,KAAK,CAAC,UAAU,CAAC;MACrB;MAEAgD,CAAC,IAAIE,UAAU;IACnB;IAEA,MAAMC,GAAG,GAAGjC,MAAM,CAACX,MAAM,GAAG,CAAC;IAC7BmC,IAAI,GAAGV,KAAK,CAACQ,CAAC,GAAGO,IAAI,EAAEI,GAAG,EAAEJ,IAAI,IAAI,CAAC,CAAC;;IAEtC;IACA;IACA,IAAIpD,KAAK,CAAC6C,CAAC,GAAGW,GAAG,CAAC,GAAGvE,MAAM,GAAG6D,CAAC,EAAE;MAC7BzC,KAAK,CAAC,UAAU,CAAC;IACrB;IAEAyC,CAAC,IAAI9C,KAAK,CAAC6C,CAAC,GAAGW,GAAG,CAAC;IACnBX,CAAC,IAAIW,GAAG;;IAER;IACAjC,MAAM,CAACkC,MAAM,CAACZ,CAAC,EAAE,EAAE,CAAC,EAAEC,CAAC,CAAC;EAC5B;EAEA,OAAO3C,MAAM,CAAC4B,aAAa,CAAC,GAAGR,MAAM,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmC,MAAM,GAAG,SAAAA,CAAUf,KAAK,EAAE;EAC5B,MAAMpB,MAAM,GAAG,EAAE;;EAEjB;EACAoB,KAAK,GAAGtB,UAAU,CAACsB,KAAK,CAAC;;EAEzB;EACA,MAAMC,WAAW,GAAGD,KAAK,CAAC/B,MAAM;;EAEhC;EACA,IAAIkC,CAAC,GAAGtD,QAAQ;EAChB,IAAI8C,KAAK,GAAG,CAAC;EACb,IAAIS,IAAI,GAAGxD,WAAW;;EAEtB;EACA,KAAK,MAAMoE,YAAY,IAAIhB,KAAK,EAAE;IAC9B,IAAIgB,YAAY,GAAG,IAAI,EAAE;MACrBpC,MAAM,CAACK,IAAI,CAAC1B,kBAAkB,CAACyD,YAAY,CAAC,CAAC;IACjD;EACJ;EAEA,MAAMC,WAAW,GAAGrC,MAAM,CAACX,MAAM;EACjC,IAAIiD,cAAc,GAAGD,WAAW;;EAEhC;EACA;;EAEA;EACA,IAAIA,WAAW,EAAE;IACbrC,MAAM,CAACK,IAAI,CAACnC,SAAS,CAAC;EAC1B;;EAEA;EACA,OAAOoE,cAAc,GAAGjB,WAAW,EAAE;IACjC;IACA;IACA,IAAIkB,CAAC,GAAG7E,MAAM;IACd,KAAK,MAAM0E,YAAY,IAAIhB,KAAK,EAAE;MAC9B,IAAIgB,YAAY,IAAIb,CAAC,IAAIa,YAAY,GAAGG,CAAC,EAAE;QACvCA,CAAC,GAAGH,YAAY;MACpB;IACJ;;IAEA;IACA;IACA,MAAMI,qBAAqB,GAAGF,cAAc,GAAG,CAAC;IAChD,IAAIC,CAAC,GAAGhB,CAAC,GAAG9C,KAAK,CAAC,CAACf,MAAM,GAAGqD,KAAK,IAAIyB,qBAAqB,CAAC,EAAE;MACzD1D,KAAK,CAAC,UAAU,CAAC;IACrB;IAEAiC,KAAK,IAAI,CAACwB,CAAC,GAAGhB,CAAC,IAAIiB,qBAAqB;IACxCjB,CAAC,GAAGgB,CAAC;IAEL,KAAK,MAAMH,YAAY,IAAIhB,KAAK,EAAE;MAC9B,IAAIgB,YAAY,GAAGb,CAAC,IAAI,EAAER,KAAK,GAAGrD,MAAM,EAAE;QACtCoB,KAAK,CAAC,UAAU,CAAC;MACrB;MACA,IAAIsD,YAAY,KAAKb,CAAC,EAAE;QACpB;QACA,IAAIkB,CAAC,GAAG1B,KAAK;QACb,KAAK,IAAIG,CAAC,GAAGvD,IAAI,CAAC,qBAAsBuD,CAAC,IAAIvD,IAAI,EAAE;UAC/C,MAAMoE,CAAC,GAAGb,CAAC,IAAIM,IAAI,GAAG5D,IAAI,GAAGsD,CAAC,IAAIM,IAAI,GAAG3D,IAAI,GAAGA,IAAI,GAAGqD,CAAC,GAAGM,IAAI;UAC/D,IAAIiB,CAAC,GAAGV,CAAC,EAAE;YACP;UACJ;UACA,MAAMW,OAAO,GAAGD,CAAC,GAAGV,CAAC;UACrB,MAAMC,UAAU,GAAGrE,IAAI,GAAGoE,CAAC;UAC3B/B,MAAM,CAACK,IAAI,CAAC1B,kBAAkB,CAACgC,YAAY,CAACoB,CAAC,GAAIW,OAAO,GAAGV,UAAW,EAAE,CAAC,CAAC,CAAC,CAAC;UAC5ES,CAAC,GAAGhE,KAAK,CAACiE,OAAO,GAAGV,UAAU,CAAC;QACnC;QAEAhC,MAAM,CAACK,IAAI,CAAC1B,kBAAkB,CAACgC,YAAY,CAAC8B,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACnDjB,IAAI,GAAGV,KAAK,CAACC,KAAK,EAAEyB,qBAAqB,EAAEF,cAAc,KAAKD,WAAW,CAAC;QAC1EtB,KAAK,GAAG,CAAC;QACT,EAAEuB,cAAc;MACpB;IACJ;IAEA,EAAEvB,KAAK;IACP,EAAEQ,CAAC;EACP;EACA,OAAOvB,MAAM,CAACH,IAAI,CAAC,EAAE,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8C,SAAS,GAAG,SAAAA,CAAUvB,KAAK,EAAE;EAC/B,OAAO9B,SAAS,CAAC8B,KAAK,EAAE,UAAUrB,MAAM,EAAE;IACtC,OAAO5B,aAAa,CAACyE,IAAI,CAAC7C,MAAM,CAAC,GAAGoB,MAAM,CAACpB,MAAM,CAAC8C,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC,GAAG/C,MAAM;EACtF,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgD,OAAO,GAAG,SAAAA,CAAU3B,KAAK,EAAE;EAC7B,OAAO9B,SAAS,CAAC8B,KAAK,EAAE,UAAUrB,MAAM,EAAE;IACtC,OAAO3B,aAAa,CAACwE,IAAI,CAAC7C,MAAM,CAAC,GAAG,MAAM,GAAGoC,MAAM,CAACpC,MAAM,CAAC,GAAGA,MAAM;EACxE,CAAC,CAAC;AACN,CAAC;;AAED;;AAEA;AACA,MAAMiD,QAAQ,GAAG;EACb;AACJ;AACA;AACA;AACA;EACIC,OAAO,EAAE,OAAO;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,IAAI,EAAE;IACF/B,MAAM,EAAErB,UAAU;IAClBqC,MAAM,EAAE7B;EACZ,CAAC;EACDa,MAAM,EAAEA,MAAM;EACdgB,MAAM,EAAEA,MAAM;EACdY,OAAO,EAAEA,OAAO;EAChBJ,SAAS,EAAEA;AACf,CAAC;AAEDQ,MAAM,CAACC,OAAO,GAAGJ,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}