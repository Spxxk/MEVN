{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CronTime = void 0;\nconst luxon_1 = require(\"luxon\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nclass CronTime {\n  constructor(source, timeZone, utcOffset) {\n    this.realDate = false;\n    this.second = {};\n    this.minute = {};\n    this.hour = {};\n    this.dayOfMonth = {};\n    this.month = {};\n    this.dayOfWeek = {};\n    if (timeZone != null && utcOffset != null) {\n      throw new errors_1.ExclusiveParametersError('timeZone', 'utcOffset');\n    }\n    if (timeZone) {\n      const dt = luxon_1.DateTime.fromObject({}, {\n        zone: timeZone\n      });\n      if (!dt.isValid) {\n        throw new errors_1.CronError('Invalid timezone.');\n      }\n      this.timeZone = timeZone;\n    }\n    if (utcOffset != null) {\n      this.utcOffset = utcOffset;\n    }\n    if (source instanceof Date || source instanceof luxon_1.DateTime) {\n      this.source = source instanceof Date ? luxon_1.DateTime.fromJSDate(source) : source;\n      this.realDate = true;\n    } else {\n      this.source = source;\n      this._parse(this.source);\n      this._verifyParse();\n    }\n  }\n  _getWeekDay(date) {\n    return date.weekday === 7 ? 0 : date.weekday;\n  }\n  _verifyParse() {\n    const months = (0, utils_1.getRecordKeys)(this.month);\n    const daysOfMonth = (0, utils_1.getRecordKeys)(this.dayOfMonth);\n    let isOk = false;\n    let lastWrongMonth = null;\n    for (const m of months) {\n      const con = constants_1.MONTH_CONSTRAINTS[m];\n      for (const day of daysOfMonth) {\n        if (day <= con) {\n          isOk = true;\n        }\n      }\n      if (!isOk) {\n        lastWrongMonth = m;\n        console.warn(`Month '${m}' is limited to '${con}' days.`);\n      }\n    }\n    if (!isOk && lastWrongMonth !== null) {\n      const notOkCon = constants_1.MONTH_CONSTRAINTS[lastWrongMonth];\n      for (const notOkDay of daysOfMonth) {\n        if (notOkDay > notOkCon) {\n          delete this.dayOfMonth[notOkDay];\n          const fixedDay = notOkDay % notOkCon;\n          this.dayOfMonth[fixedDay] = true;\n        }\n      }\n    }\n  }\n  sendAt(i) {\n    let date = this.realDate && this.source instanceof luxon_1.DateTime ? this.source : luxon_1.DateTime.local();\n    if (this.timeZone) {\n      date = date.setZone(this.timeZone);\n    }\n    if (this.utcOffset !== undefined) {\n      const sign = this.utcOffset < 0 ? '-' : '+';\n      const offsetHours = Math.trunc(this.utcOffset / 60);\n      const offsetHoursStr = String(Math.abs(offsetHours)).padStart(2, '0');\n      const offsetMins = Math.abs(this.utcOffset - offsetHours * 60);\n      const offsetMinsStr = String(offsetMins).padStart(2, '0');\n      const utcZone = `UTC${sign}${offsetHoursStr}:${offsetMinsStr}`;\n      date = date.setZone(utcZone);\n      if (!date.isValid) {\n        throw new errors_1.CronError('ERROR: You specified an invalid UTC offset.');\n      }\n    }\n    if (this.realDate) {\n      if (luxon_1.DateTime.local() > date) {\n        throw new errors_1.CronError('WARNING: Date in past. Will never be fired.');\n      }\n      return date;\n    }\n    if (i === undefined || isNaN(i) || i < 0) {\n      return this.getNextDateFrom(date);\n    } else {\n      const dates = [];\n      for (; i > 0; i--) {\n        date = this.getNextDateFrom(date);\n        dates.push(date);\n      }\n      return dates;\n    }\n  }\n  getTimeout() {\n    return Math.max(-1, this.sendAt().toMillis() - luxon_1.DateTime.local().toMillis());\n  }\n  toString() {\n    return this.toJSON().join(' ');\n  }\n  toJSON() {\n    return constants_1.TIME_UNITS.map(unit => {\n      return this._wcOrAll(unit);\n    });\n  }\n  getNextDateFrom(start, timeZone) {\n    var _a;\n    if (start instanceof Date) {\n      start = luxon_1.DateTime.fromJSDate(start);\n    }\n    let date = start;\n    const firstDate = start.toMillis();\n    if (timeZone) {\n      date = date.setZone(timeZone);\n    }\n    if (!this.realDate) {\n      if (date.millisecond > 0) {\n        date = date.set({\n          millisecond: 0,\n          second: date.second + 1\n        });\n      }\n    }\n    if (!date.isValid) {\n      throw new errors_1.CronError('ERROR: You specified an invalid date.');\n    }\n    const maxMatch = luxon_1.DateTime.now().plus({\n      years: 8\n    });\n    while (true) {\n      const diff = date.toMillis() - start.toMillis();\n      if (date > maxMatch) {\n        throw new errors_1.CronError(`Something went wrong. No execution date was found in the next 8 years.\n\t\t\t\t\t\t\tPlease provide the following string if you would like to help debug:\n\t\t\t\t\t\t\tTime Zone: ${(_a = timeZone === null || timeZone === void 0 ? void 0 : timeZone.toString()) !== null && _a !== void 0 ? _a : '\"\"'} - Cron String: ${this.source.toString()} - UTC offset: ${date.offset} - current Date: ${luxon_1.DateTime.local().toString()}`);\n      }\n      if (!(date.month in this.month) && Object.keys(this.month).length !== 12) {\n        date = date.plus({\n          months: 1\n        });\n        date = date.set({\n          day: 1,\n          hour: 0,\n          minute: 0,\n          second: 0\n        });\n        if (this._forwardDSTJump(0, 0, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (!(date.day in this.dayOfMonth) && Object.keys(this.dayOfMonth).length !== 31 && !(this._getWeekDay(date) in this.dayOfWeek && Object.keys(this.dayOfWeek).length !== 7)) {\n        date = date.plus({\n          days: 1\n        });\n        date = date.set({\n          hour: 0,\n          minute: 0,\n          second: 0\n        });\n        if (this._forwardDSTJump(0, 0, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (!(this._getWeekDay(date) in this.dayOfWeek) && Object.keys(this.dayOfWeek).length !== 7 && !(date.day in this.dayOfMonth && Object.keys(this.dayOfMonth).length !== 31)) {\n        date = date.plus({\n          days: 1\n        });\n        date = date.set({\n          hour: 0,\n          minute: 0,\n          second: 0\n        });\n        if (this._forwardDSTJump(0, 0, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (!(date.hour in this.hour) && Object.keys(this.hour).length !== 24) {\n        const expectedHour = date.hour === 23 && diff > 86400000 ? 0 : date.hour + 1;\n        const expectedMinute = date.minute;\n        date = date.set({\n          hour: expectedHour\n        });\n        date = date.set({\n          minute: 0,\n          second: 0\n        });\n        if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (!(date.minute in this.minute) && Object.keys(this.minute).length !== 60) {\n        const expectedMinute = date.minute === 59 && diff > 3600000 ? 0 : date.minute + 1;\n        const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n        date = date.set({\n          minute: expectedMinute\n        });\n        date = date.set({\n          second: 0\n        });\n        if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (!(date.second in this.second) && Object.keys(this.second).length !== 60) {\n        const expectedSecond = date.second === 59 && diff > 60000 ? 0 : date.second + 1;\n        const expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n        const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n        date = date.set({\n          second: expectedSecond\n        });\n        if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      if (date.toMillis() === firstDate) {\n        const expectedSecond = date.second + 1;\n        const expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n        const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n        date = date.set({\n          second: expectedSecond\n        });\n        if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n          const [isDone, newDate] = this._findPreviousDSTJump(date);\n          date = newDate;\n          if (isDone) break;\n        }\n        continue;\n      }\n      break;\n    }\n    return date;\n  }\n  _findPreviousDSTJump(date) {\n    var _a;\n    let expectedMinute, expectedHour, actualMinute, actualHour;\n    let maybeJumpingPoint = date;\n    const iterationLimit = 60 * 24;\n    let iteration = 0;\n    do {\n      if (++iteration > iterationLimit) {\n        throw new errors_1.CronError(`ERROR: This DST checking related function assumes the input DateTime (${(_a = date.toISO()) !== null && _a !== void 0 ? _a : date.toMillis()}) is within 24 hours of a DST jump.`);\n      }\n      expectedMinute = maybeJumpingPoint.minute - 1;\n      expectedHour = maybeJumpingPoint.hour;\n      if (expectedMinute < 0) {\n        expectedMinute += 60;\n        expectedHour = (expectedHour + 24 - 1) % 24;\n      }\n      maybeJumpingPoint = maybeJumpingPoint.minus({\n        minute: 1\n      });\n      actualMinute = maybeJumpingPoint.minute;\n      actualHour = maybeJumpingPoint.hour;\n    } while (expectedMinute === actualMinute && expectedHour === actualHour);\n    const afterJumpingPoint = maybeJumpingPoint.plus({\n      minute: 1\n    }).set({\n      second: 0,\n      millisecond: 0\n    });\n    const beforeJumpingPoint = afterJumpingPoint.minus({\n      second: 1\n    });\n    if (date.month + 1 in this.month && date.day in this.dayOfMonth && this._getWeekDay(date) in this.dayOfWeek) {\n      return [this._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint), afterJumpingPoint];\n    }\n    return [false, afterJumpingPoint];\n  }\n  _checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint) {\n    const startingMinute = (beforeJumpingPoint.minute + 1) % 60;\n    const startingHour = (beforeJumpingPoint.hour + (startingMinute === 0 ? 1 : 0)) % 24;\n    const hourRangeSize = afterJumpingPoint.hour - startingHour + 1;\n    const isHourJump = startingMinute === 0 && afterJumpingPoint.minute === 0;\n    if (hourRangeSize === 2 && isHourJump) {\n      return startingHour in this.hour;\n    } else if (hourRangeSize === 1) {\n      return startingHour in this.hour && this._checkTimeInSkippedRangeSingleHour(startingMinute, afterJumpingPoint.minute);\n    } else {\n      return this._checkTimeInSkippedRangeMultiHour(startingHour, startingMinute, afterJumpingPoint.hour, afterJumpingPoint.minute);\n    }\n  }\n  _checkTimeInSkippedRangeSingleHour(startMinute, endMinute) {\n    for (let minute = startMinute; minute < endMinute; ++minute) {\n      if (minute in this.minute) return true;\n    }\n    return endMinute in this.minute && 0 in this.second;\n  }\n  _checkTimeInSkippedRangeMultiHour(startHour, startMinute, endHour, endMinute) {\n    if (startHour >= endHour) {\n      throw new errors_1.CronError(`ERROR: This DST checking related function assumes the forward jump starting hour (${startHour}) is less than the end hour (${endHour})`);\n    }\n    const firstHourMinuteRange = Array.from({\n      length: 60 - startMinute\n    }, (_, k) => startMinute + k);\n    const lastHourMinuteRange = Array.from({\n      length: endMinute\n    }, (_, k) => k);\n    const middleHourMinuteRange = Array.from({\n      length: 60\n    }, (_, k) => k);\n    const selectRange = forHour => {\n      if (forHour === startHour) {\n        return firstHourMinuteRange;\n      } else if (forHour === endHour) {\n        return lastHourMinuteRange;\n      } else {\n        return middleHourMinuteRange;\n      }\n    };\n    for (let hour = startHour; hour <= endHour; ++hour) {\n      if (!(hour in this.hour)) continue;\n      const usingRange = selectRange(hour);\n      for (const minute of usingRange) {\n        if (minute in this.minute) return true;\n      }\n    }\n    return endHour in this.hour && endMinute in this.minute && 0 in this.second;\n  }\n  _forwardDSTJump(expectedHour, expectedMinute, actualDate) {\n    const actualHour = actualDate.hour;\n    const actualMinute = actualDate.minute;\n    const didHoursJumped = expectedHour % 24 < actualHour;\n    const didMinutesJumped = expectedMinute % 60 < actualMinute;\n    return didHoursJumped || didMinutesJumped;\n  }\n  _wcOrAll(unit) {\n    if (this._hasAll(unit)) {\n      return '*';\n    }\n    const all = [];\n    for (const time in this[unit]) {\n      all.push(time);\n    }\n    return all.join(',');\n  }\n  _hasAll(unit) {\n    const constraints = constants_1.CONSTRAINTS[unit];\n    const low = constraints[0];\n    const high = unit === constants_1.TIME_UNITS_MAP.DAY_OF_WEEK ? constraints[1] - 1 : constraints[1];\n    for (let i = low, n = high; i < n; i++) {\n      if (!(i in this[unit])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _parse(source) {\n    var _a;\n    source = source.toLowerCase();\n    if (Object.keys(constants_1.PRESETS).includes(source)) {\n      source = constants_1.PRESETS[source];\n    }\n    source = source.replace(/[a-z]{1,3}/gi, alias => {\n      if (Object.keys(constants_1.ALIASES).includes(alias)) {\n        return constants_1.ALIASES[alias].toString();\n      }\n      throw new errors_1.CronError(`Unknown alias: ${alias}`);\n    });\n    const units = source.trim().split(/\\s+/);\n    if (units.length < constants_1.TIME_UNITS_LEN - 1) {\n      throw new errors_1.CronError('Too few fields');\n    }\n    if (units.length > constants_1.TIME_UNITS_LEN) {\n      throw new errors_1.CronError('Too many fields');\n    }\n    const unitsLen = units.length;\n    for (const unit of constants_1.TIME_UNITS) {\n      const i = constants_1.TIME_UNITS.indexOf(unit);\n      const cur = (_a = units[i - (constants_1.TIME_UNITS_LEN - unitsLen)]) !== null && _a !== void 0 ? _a : constants_1.PARSE_DEFAULTS[unit];\n      this._parseField(cur, unit);\n    }\n  }\n  _parseField(value, unit) {\n    const typeObj = this[unit];\n    let pointer;\n    const constraints = constants_1.CONSTRAINTS[unit];\n    const low = constraints[0];\n    const high = constraints[1];\n    const fields = value.split(',');\n    fields.forEach(field => {\n      const wildcardIndex = field.indexOf('*');\n      if (wildcardIndex !== -1 && wildcardIndex !== 0) {\n        throw new errors_1.CronError(`Field (${field}) has an invalid wildcard expression`);\n      }\n    });\n    value = value.replace(constants_1.RE_WILDCARDS, `${low}-${high}`);\n    const allRanges = value.split(',');\n    for (const range of allRanges) {\n      const match = [...range.matchAll(constants_1.RE_RANGE)][0];\n      if ((match === null || match === void 0 ? void 0 : match[1]) !== undefined) {\n        const [, mLower, mUpper, mStep] = match;\n        let lower = parseInt(mLower, 10);\n        let upper = mUpper !== undefined ? parseInt(mUpper, 10) : undefined;\n        const wasStepDefined = mStep !== undefined;\n        const step = parseInt(mStep !== null && mStep !== void 0 ? mStep : '1', 10);\n        if (step === 0) {\n          throw new errors_1.CronError(`Field (${unit}) has a step of zero`);\n        }\n        if (upper !== undefined && lower > upper) {\n          throw new errors_1.CronError(`Field (${unit}) has an invalid range`);\n        }\n        const isOutOfRange = lower < low || upper !== undefined && upper > high || upper === undefined && lower > high;\n        if (isOutOfRange) {\n          throw new errors_1.CronError(`Field value (${value}) is out of range`);\n        }\n        lower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n        if (upper !== undefined) {\n          upper = Math.min(high, ~~Math.abs(upper));\n        } else {\n          upper = wasStepDefined ? high : lower;\n        }\n        pointer = lower;\n        do {\n          typeObj[pointer] = true;\n          pointer += step;\n        } while (pointer <= upper);\n        if (unit === 'dayOfWeek') {\n          if (!typeObj[0] && !!typeObj[7]) typeObj[0] = typeObj[7];\n          delete typeObj[7];\n        }\n      } else {\n        throw new errors_1.CronError(`Field (${unit}) cannot be parsed`);\n      }\n    }\n  }\n}\nexports.CronTime = CronTime;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","CronTime","luxon_1","constants_1","errors_1","utils_1","constructor","source","timeZone","utcOffset","realDate","second","minute","hour","dayOfMonth","month","dayOfWeek","ExclusiveParametersError","dt","DateTime","fromObject","zone","isValid","CronError","Date","fromJSDate","_parse","_verifyParse","_getWeekDay","date","weekday","months","getRecordKeys","daysOfMonth","isOk","lastWrongMonth","m","con","MONTH_CONSTRAINTS","day","console","warn","notOkCon","notOkDay","fixedDay","sendAt","i","local","setZone","undefined","sign","offsetHours","Math","trunc","offsetHoursStr","String","abs","padStart","offsetMins","offsetMinsStr","utcZone","isNaN","getNextDateFrom","dates","push","getTimeout","max","toMillis","toString","toJSON","join","TIME_UNITS","map","unit","_wcOrAll","start","_a","firstDate","millisecond","set","maxMatch","now","plus","years","diff","offset","keys","length","_forwardDSTJump","isDone","newDate","_findPreviousDSTJump","days","expectedHour","expectedMinute","expectedSecond","actualMinute","actualHour","maybeJumpingPoint","iterationLimit","iteration","toISO","minus","afterJumpingPoint","beforeJumpingPoint","_checkTimeInSkippedRange","startingMinute","startingHour","hourRangeSize","isHourJump","_checkTimeInSkippedRangeSingleHour","_checkTimeInSkippedRangeMultiHour","startMinute","endMinute","startHour","endHour","firstHourMinuteRange","Array","from","_","k","lastHourMinuteRange","middleHourMinuteRange","selectRange","forHour","usingRange","actualDate","didHoursJumped","didMinutesJumped","_hasAll","all","time","constraints","CONSTRAINTS","low","high","TIME_UNITS_MAP","DAY_OF_WEEK","n","toLowerCase","PRESETS","includes","replace","alias","ALIASES","units","trim","split","TIME_UNITS_LEN","unitsLen","indexOf","cur","PARSE_DEFAULTS","_parseField","typeObj","pointer","fields","forEach","field","wildcardIndex","RE_WILDCARDS","allRanges","range","match","matchAll","RE_RANGE","mLower","mUpper","mStep","lower","parseInt","upper","wasStepDefined","step","isOutOfRange","min"],"sources":["C:/Users/jason/Desktop/owen/frontend/node_modules/cron/dist/time.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CronTime = void 0;\nconst luxon_1 = require(\"luxon\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nclass CronTime {\n    constructor(source, timeZone, utcOffset) {\n        this.realDate = false;\n        this.second = {};\n        this.minute = {};\n        this.hour = {};\n        this.dayOfMonth = {};\n        this.month = {};\n        this.dayOfWeek = {};\n        if (timeZone != null && utcOffset != null) {\n            throw new errors_1.ExclusiveParametersError('timeZone', 'utcOffset');\n        }\n        if (timeZone) {\n            const dt = luxon_1.DateTime.fromObject({}, { zone: timeZone });\n            if (!dt.isValid) {\n                throw new errors_1.CronError('Invalid timezone.');\n            }\n            this.timeZone = timeZone;\n        }\n        if (utcOffset != null) {\n            this.utcOffset = utcOffset;\n        }\n        if (source instanceof Date || source instanceof luxon_1.DateTime) {\n            this.source =\n                source instanceof Date ? luxon_1.DateTime.fromJSDate(source) : source;\n            this.realDate = true;\n        }\n        else {\n            this.source = source;\n            this._parse(this.source);\n            this._verifyParse();\n        }\n    }\n    _getWeekDay(date) {\n        return date.weekday === 7 ? 0 : date.weekday;\n    }\n    _verifyParse() {\n        const months = (0, utils_1.getRecordKeys)(this.month);\n        const daysOfMonth = (0, utils_1.getRecordKeys)(this.dayOfMonth);\n        let isOk = false;\n        let lastWrongMonth = null;\n        for (const m of months) {\n            const con = constants_1.MONTH_CONSTRAINTS[m];\n            for (const day of daysOfMonth) {\n                if (day <= con) {\n                    isOk = true;\n                }\n            }\n            if (!isOk) {\n                lastWrongMonth = m;\n                console.warn(`Month '${m}' is limited to '${con}' days.`);\n            }\n        }\n        if (!isOk && lastWrongMonth !== null) {\n            const notOkCon = constants_1.MONTH_CONSTRAINTS[lastWrongMonth];\n            for (const notOkDay of daysOfMonth) {\n                if (notOkDay > notOkCon) {\n                    delete this.dayOfMonth[notOkDay];\n                    const fixedDay = (notOkDay % notOkCon);\n                    this.dayOfMonth[fixedDay] = true;\n                }\n            }\n        }\n    }\n    sendAt(i) {\n        let date = this.realDate && this.source instanceof luxon_1.DateTime\n            ? this.source\n            : luxon_1.DateTime.local();\n        if (this.timeZone) {\n            date = date.setZone(this.timeZone);\n        }\n        if (this.utcOffset !== undefined) {\n            const sign = this.utcOffset < 0 ? '-' : '+';\n            const offsetHours = Math.trunc(this.utcOffset / 60);\n            const offsetHoursStr = String(Math.abs(offsetHours)).padStart(2, '0');\n            const offsetMins = Math.abs(this.utcOffset - offsetHours * 60);\n            const offsetMinsStr = String(offsetMins).padStart(2, '0');\n            const utcZone = `UTC${sign}${offsetHoursStr}:${offsetMinsStr}`;\n            date = date.setZone(utcZone);\n            if (!date.isValid) {\n                throw new errors_1.CronError('ERROR: You specified an invalid UTC offset.');\n            }\n        }\n        if (this.realDate) {\n            if (luxon_1.DateTime.local() > date) {\n                throw new errors_1.CronError('WARNING: Date in past. Will never be fired.');\n            }\n            return date;\n        }\n        if (i === undefined || isNaN(i) || i < 0) {\n            return this.getNextDateFrom(date);\n        }\n        else {\n            const dates = [];\n            for (; i > 0; i--) {\n                date = this.getNextDateFrom(date);\n                dates.push(date);\n            }\n            return dates;\n        }\n    }\n    getTimeout() {\n        return Math.max(-1, this.sendAt().toMillis() - luxon_1.DateTime.local().toMillis());\n    }\n    toString() {\n        return this.toJSON().join(' ');\n    }\n    toJSON() {\n        return constants_1.TIME_UNITS.map(unit => {\n            return this._wcOrAll(unit);\n        });\n    }\n    getNextDateFrom(start, timeZone) {\n        var _a;\n        if (start instanceof Date) {\n            start = luxon_1.DateTime.fromJSDate(start);\n        }\n        let date = start;\n        const firstDate = start.toMillis();\n        if (timeZone) {\n            date = date.setZone(timeZone);\n        }\n        if (!this.realDate) {\n            if (date.millisecond > 0) {\n                date = date.set({ millisecond: 0, second: date.second + 1 });\n            }\n        }\n        if (!date.isValid) {\n            throw new errors_1.CronError('ERROR: You specified an invalid date.');\n        }\n        const maxMatch = luxon_1.DateTime.now().plus({ years: 8 });\n        while (true) {\n            const diff = date.toMillis() - start.toMillis();\n            if (date > maxMatch) {\n                throw new errors_1.CronError(`Something went wrong. No execution date was found in the next 8 years.\n\t\t\t\t\t\t\tPlease provide the following string if you would like to help debug:\n\t\t\t\t\t\t\tTime Zone: ${(_a = timeZone === null || timeZone === void 0 ? void 0 : timeZone.toString()) !== null && _a !== void 0 ? _a : '\"\"'} - Cron String: ${this.source.toString()} - UTC offset: ${date.offset} - current Date: ${luxon_1.DateTime.local().toString()}`);\n            }\n            if (!(date.month in this.month) &&\n                Object.keys(this.month).length !== 12) {\n                date = date.plus({ months: 1 });\n                date = date.set({ day: 1, hour: 0, minute: 0, second: 0 });\n                if (this._forwardDSTJump(0, 0, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (!(date.day in this.dayOfMonth) &&\n                Object.keys(this.dayOfMonth).length !== 31 &&\n                !(this._getWeekDay(date) in this.dayOfWeek &&\n                    Object.keys(this.dayOfWeek).length !== 7)) {\n                date = date.plus({ days: 1 });\n                date = date.set({ hour: 0, minute: 0, second: 0 });\n                if (this._forwardDSTJump(0, 0, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (!(this._getWeekDay(date) in this.dayOfWeek) &&\n                Object.keys(this.dayOfWeek).length !== 7 &&\n                !(date.day in this.dayOfMonth &&\n                    Object.keys(this.dayOfMonth).length !== 31)) {\n                date = date.plus({ days: 1 });\n                date = date.set({ hour: 0, minute: 0, second: 0 });\n                if (this._forwardDSTJump(0, 0, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (!(date.hour in this.hour) && Object.keys(this.hour).length !== 24) {\n                const expectedHour = date.hour === 23 && diff > 86400000 ? 0 : date.hour + 1;\n                const expectedMinute = date.minute;\n                date = date.set({ hour: expectedHour });\n                date = date.set({ minute: 0, second: 0 });\n                if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (!(date.minute in this.minute) &&\n                Object.keys(this.minute).length !== 60) {\n                const expectedMinute = date.minute === 59 && diff > 3600000 ? 0 : date.minute + 1;\n                const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n                date = date.set({ minute: expectedMinute });\n                date = date.set({ second: 0 });\n                if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (!(date.second in this.second) &&\n                Object.keys(this.second).length !== 60) {\n                const expectedSecond = date.second === 59 && diff > 60000 ? 0 : date.second + 1;\n                const expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n                const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n                date = date.set({ second: expectedSecond });\n                if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            if (date.toMillis() === firstDate) {\n                const expectedSecond = date.second + 1;\n                const expectedMinute = date.minute + (expectedSecond === 60 ? 1 : 0);\n                const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n                date = date.set({ second: expectedSecond });\n                if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n                    const [isDone, newDate] = this._findPreviousDSTJump(date);\n                    date = newDate;\n                    if (isDone)\n                        break;\n                }\n                continue;\n            }\n            break;\n        }\n        return date;\n    }\n    _findPreviousDSTJump(date) {\n        var _a;\n        let expectedMinute, expectedHour, actualMinute, actualHour;\n        let maybeJumpingPoint = date;\n        const iterationLimit = 60 * 24;\n        let iteration = 0;\n        do {\n            if (++iteration > iterationLimit) {\n                throw new errors_1.CronError(`ERROR: This DST checking related function assumes the input DateTime (${(_a = date.toISO()) !== null && _a !== void 0 ? _a : date.toMillis()}) is within 24 hours of a DST jump.`);\n            }\n            expectedMinute = maybeJumpingPoint.minute - 1;\n            expectedHour = maybeJumpingPoint.hour;\n            if (expectedMinute < 0) {\n                expectedMinute += 60;\n                expectedHour = (expectedHour + 24 - 1) % 24;\n            }\n            maybeJumpingPoint = maybeJumpingPoint.minus({ minute: 1 });\n            actualMinute = maybeJumpingPoint.minute;\n            actualHour = maybeJumpingPoint.hour;\n        } while (expectedMinute === actualMinute && expectedHour === actualHour);\n        const afterJumpingPoint = maybeJumpingPoint\n            .plus({ minute: 1 })\n            .set({ second: 0, millisecond: 0 });\n        const beforeJumpingPoint = afterJumpingPoint.minus({ second: 1 });\n        if (date.month + 1 in this.month &&\n            date.day in this.dayOfMonth &&\n            this._getWeekDay(date) in this.dayOfWeek) {\n            return [\n                this._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint),\n                afterJumpingPoint\n            ];\n        }\n        return [false, afterJumpingPoint];\n    }\n    _checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint) {\n        const startingMinute = (beforeJumpingPoint.minute + 1) % 60;\n        const startingHour = (beforeJumpingPoint.hour + (startingMinute === 0 ? 1 : 0)) % 24;\n        const hourRangeSize = afterJumpingPoint.hour - startingHour + 1;\n        const isHourJump = startingMinute === 0 && afterJumpingPoint.minute === 0;\n        if (hourRangeSize === 2 && isHourJump) {\n            return startingHour in this.hour;\n        }\n        else if (hourRangeSize === 1) {\n            return (startingHour in this.hour &&\n                this._checkTimeInSkippedRangeSingleHour(startingMinute, afterJumpingPoint.minute));\n        }\n        else {\n            return this._checkTimeInSkippedRangeMultiHour(startingHour, startingMinute, afterJumpingPoint.hour, afterJumpingPoint.minute);\n        }\n    }\n    _checkTimeInSkippedRangeSingleHour(startMinute, endMinute) {\n        for (let minute = startMinute; minute < endMinute; ++minute) {\n            if (minute in this.minute)\n                return true;\n        }\n        return endMinute in this.minute && 0 in this.second;\n    }\n    _checkTimeInSkippedRangeMultiHour(startHour, startMinute, endHour, endMinute) {\n        if (startHour >= endHour) {\n            throw new errors_1.CronError(`ERROR: This DST checking related function assumes the forward jump starting hour (${startHour}) is less than the end hour (${endHour})`);\n        }\n        const firstHourMinuteRange = Array.from({ length: 60 - startMinute }, (_, k) => startMinute + k);\n        const lastHourMinuteRange = Array.from({ length: endMinute }, (_, k) => k);\n        const middleHourMinuteRange = Array.from({ length: 60 }, (_, k) => k);\n        const selectRange = (forHour) => {\n            if (forHour === startHour) {\n                return firstHourMinuteRange;\n            }\n            else if (forHour === endHour) {\n                return lastHourMinuteRange;\n            }\n            else {\n                return middleHourMinuteRange;\n            }\n        };\n        for (let hour = startHour; hour <= endHour; ++hour) {\n            if (!(hour in this.hour))\n                continue;\n            const usingRange = selectRange(hour);\n            for (const minute of usingRange) {\n                if (minute in this.minute)\n                    return true;\n            }\n        }\n        return endHour in this.hour && endMinute in this.minute && 0 in this.second;\n    }\n    _forwardDSTJump(expectedHour, expectedMinute, actualDate) {\n        const actualHour = actualDate.hour;\n        const actualMinute = actualDate.minute;\n        const didHoursJumped = expectedHour % 24 < actualHour;\n        const didMinutesJumped = expectedMinute % 60 < actualMinute;\n        return didHoursJumped || didMinutesJumped;\n    }\n    _wcOrAll(unit) {\n        if (this._hasAll(unit)) {\n            return '*';\n        }\n        const all = [];\n        for (const time in this[unit]) {\n            all.push(time);\n        }\n        return all.join(',');\n    }\n    _hasAll(unit) {\n        const constraints = constants_1.CONSTRAINTS[unit];\n        const low = constraints[0];\n        const high = unit === constants_1.TIME_UNITS_MAP.DAY_OF_WEEK ? constraints[1] - 1 : constraints[1];\n        for (let i = low, n = high; i < n; i++) {\n            if (!(i in this[unit])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _parse(source) {\n        var _a;\n        source = source.toLowerCase();\n        if (Object.keys(constants_1.PRESETS).includes(source)) {\n            source = constants_1.PRESETS[source];\n        }\n        source = source.replace(/[a-z]{1,3}/gi, (alias) => {\n            if (Object.keys(constants_1.ALIASES).includes(alias)) {\n                return constants_1.ALIASES[alias].toString();\n            }\n            throw new errors_1.CronError(`Unknown alias: ${alias}`);\n        });\n        const units = source.trim().split(/\\s+/);\n        if (units.length < constants_1.TIME_UNITS_LEN - 1) {\n            throw new errors_1.CronError('Too few fields');\n        }\n        if (units.length > constants_1.TIME_UNITS_LEN) {\n            throw new errors_1.CronError('Too many fields');\n        }\n        const unitsLen = units.length;\n        for (const unit of constants_1.TIME_UNITS) {\n            const i = constants_1.TIME_UNITS.indexOf(unit);\n            const cur = (_a = units[i - (constants_1.TIME_UNITS_LEN - unitsLen)]) !== null && _a !== void 0 ? _a : constants_1.PARSE_DEFAULTS[unit];\n            this._parseField(cur, unit);\n        }\n    }\n    _parseField(value, unit) {\n        const typeObj = this[unit];\n        let pointer;\n        const constraints = constants_1.CONSTRAINTS[unit];\n        const low = constraints[0];\n        const high = constraints[1];\n        const fields = value.split(',');\n        fields.forEach(field => {\n            const wildcardIndex = field.indexOf('*');\n            if (wildcardIndex !== -1 && wildcardIndex !== 0) {\n                throw new errors_1.CronError(`Field (${field}) has an invalid wildcard expression`);\n            }\n        });\n        value = value.replace(constants_1.RE_WILDCARDS, `${low}-${high}`);\n        const allRanges = value.split(',');\n        for (const range of allRanges) {\n            const match = [...range.matchAll(constants_1.RE_RANGE)][0];\n            if ((match === null || match === void 0 ? void 0 : match[1]) !== undefined) {\n                const [, mLower, mUpper, mStep] = match;\n                let lower = parseInt(mLower, 10);\n                let upper = mUpper !== undefined ? parseInt(mUpper, 10) : undefined;\n                const wasStepDefined = mStep !== undefined;\n                const step = parseInt(mStep !== null && mStep !== void 0 ? mStep : '1', 10);\n                if (step === 0) {\n                    throw new errors_1.CronError(`Field (${unit}) has a step of zero`);\n                }\n                if (upper !== undefined && lower > upper) {\n                    throw new errors_1.CronError(`Field (${unit}) has an invalid range`);\n                }\n                const isOutOfRange = lower < low ||\n                    (upper !== undefined && upper > high) ||\n                    (upper === undefined && lower > high);\n                if (isOutOfRange) {\n                    throw new errors_1.CronError(`Field value (${value}) is out of range`);\n                }\n                lower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n                if (upper !== undefined) {\n                    upper = Math.min(high, ~~Math.abs(upper));\n                }\n                else {\n                    upper = wasStepDefined ? high : lower;\n                }\n                pointer = lower;\n                do {\n                    typeObj[pointer] = true;\n                    pointer += step;\n                } while (pointer <= upper);\n                if (unit === 'dayOfWeek') {\n                    if (!typeObj[0] && !!typeObj[7])\n                        typeObj[0] = typeObj[7];\n                    delete typeObj[7];\n                }\n            }\n            else {\n                throw new errors_1.CronError(`Field (${unit}) cannot be parsed`);\n            }\n        }\n    }\n}\nexports.CronTime = CronTime;\n//# sourceMappingURL=time.js.map"],"mappings":"AAAA,YAAY;;AAACA,OAAA;AACbC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,QAAQ,GAAG,KAAK,CAAC;AACzB,MAAMC,OAAO,GAAGN,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMO,WAAW,GAAGP,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMS,OAAO,GAAGT,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMK,QAAQ,CAAC;EACXK,WAAWA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAE;IACrC,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;IACd,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC;IACnB,IAAIR,QAAQ,IAAI,IAAI,IAAIC,SAAS,IAAI,IAAI,EAAE;MACvC,MAAM,IAAIL,QAAQ,CAACa,wBAAwB,CAAC,UAAU,EAAE,WAAW,CAAC;IACxE;IACA,IAAIT,QAAQ,EAAE;MACV,MAAMU,EAAE,GAAGhB,OAAO,CAACiB,QAAQ,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE;QAAEC,IAAI,EAAEb;MAAS,CAAC,CAAC;MAC9D,IAAI,CAACU,EAAE,CAACI,OAAO,EAAE;QACb,MAAM,IAAIlB,QAAQ,CAACmB,SAAS,CAAC,mBAAmB,CAAC;MACrD;MACA,IAAI,CAACf,QAAQ,GAAGA,QAAQ;IAC5B;IACA,IAAIC,SAAS,IAAI,IAAI,EAAE;MACnB,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC9B;IACA,IAAIF,MAAM,YAAYiB,IAAI,IAAIjB,MAAM,YAAYL,OAAO,CAACiB,QAAQ,EAAE;MAC9D,IAAI,CAACZ,MAAM,GACPA,MAAM,YAAYiB,IAAI,GAAGtB,OAAO,CAACiB,QAAQ,CAACM,UAAU,CAAClB,MAAM,CAAC,GAAGA,MAAM;MACzE,IAAI,CAACG,QAAQ,GAAG,IAAI;IACxB,CAAC,MACI;MACD,IAAI,CAACH,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACmB,MAAM,CAAC,IAAI,CAACnB,MAAM,CAAC;MACxB,IAAI,CAACoB,YAAY,CAAC,CAAC;IACvB;EACJ;EACAC,WAAWA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI,CAACC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAGD,IAAI,CAACC,OAAO;EAChD;EACAH,YAAYA,CAAA,EAAG;IACX,MAAMI,MAAM,GAAG,CAAC,CAAC,EAAE1B,OAAO,CAAC2B,aAAa,EAAE,IAAI,CAACjB,KAAK,CAAC;IACrD,MAAMkB,WAAW,GAAG,CAAC,CAAC,EAAE5B,OAAO,CAAC2B,aAAa,EAAE,IAAI,CAAClB,UAAU,CAAC;IAC/D,IAAIoB,IAAI,GAAG,KAAK;IAChB,IAAIC,cAAc,GAAG,IAAI;IACzB,KAAK,MAAMC,CAAC,IAAIL,MAAM,EAAE;MACpB,MAAMM,GAAG,GAAGlC,WAAW,CAACmC,iBAAiB,CAACF,CAAC,CAAC;MAC5C,KAAK,MAAMG,GAAG,IAAIN,WAAW,EAAE;QAC3B,IAAIM,GAAG,IAAIF,GAAG,EAAE;UACZH,IAAI,GAAG,IAAI;QACf;MACJ;MACA,IAAI,CAACA,IAAI,EAAE;QACPC,cAAc,GAAGC,CAAC;QAClBI,OAAO,CAACC,IAAI,CAAE,UAASL,CAAE,oBAAmBC,GAAI,SAAQ,CAAC;MAC7D;IACJ;IACA,IAAI,CAACH,IAAI,IAAIC,cAAc,KAAK,IAAI,EAAE;MAClC,MAAMO,QAAQ,GAAGvC,WAAW,CAACmC,iBAAiB,CAACH,cAAc,CAAC;MAC9D,KAAK,MAAMQ,QAAQ,IAAIV,WAAW,EAAE;QAChC,IAAIU,QAAQ,GAAGD,QAAQ,EAAE;UACrB,OAAO,IAAI,CAAC5B,UAAU,CAAC6B,QAAQ,CAAC;UAChC,MAAMC,QAAQ,GAAID,QAAQ,GAAGD,QAAS;UACtC,IAAI,CAAC5B,UAAU,CAAC8B,QAAQ,CAAC,GAAG,IAAI;QACpC;MACJ;IACJ;EACJ;EACAC,MAAMA,CAACC,CAAC,EAAE;IACN,IAAIjB,IAAI,GAAG,IAAI,CAACnB,QAAQ,IAAI,IAAI,CAACH,MAAM,YAAYL,OAAO,CAACiB,QAAQ,GAC7D,IAAI,CAACZ,MAAM,GACXL,OAAO,CAACiB,QAAQ,CAAC4B,KAAK,CAAC,CAAC;IAC9B,IAAI,IAAI,CAACvC,QAAQ,EAAE;MACfqB,IAAI,GAAGA,IAAI,CAACmB,OAAO,CAAC,IAAI,CAACxC,QAAQ,CAAC;IACtC;IACA,IAAI,IAAI,CAACC,SAAS,KAAKwC,SAAS,EAAE;MAC9B,MAAMC,IAAI,GAAG,IAAI,CAACzC,SAAS,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG;MAC3C,MAAM0C,WAAW,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC5C,SAAS,GAAG,EAAE,CAAC;MACnD,MAAM6C,cAAc,GAAGC,MAAM,CAACH,IAAI,CAACI,GAAG,CAACL,WAAW,CAAC,CAAC,CAACM,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACrE,MAAMC,UAAU,GAAGN,IAAI,CAACI,GAAG,CAAC,IAAI,CAAC/C,SAAS,GAAG0C,WAAW,GAAG,EAAE,CAAC;MAC9D,MAAMQ,aAAa,GAAGJ,MAAM,CAACG,UAAU,CAAC,CAACD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACzD,MAAMG,OAAO,GAAI,MAAKV,IAAK,GAAEI,cAAe,IAAGK,aAAc,EAAC;MAC9D9B,IAAI,GAAGA,IAAI,CAACmB,OAAO,CAACY,OAAO,CAAC;MAC5B,IAAI,CAAC/B,IAAI,CAACP,OAAO,EAAE;QACf,MAAM,IAAIlB,QAAQ,CAACmB,SAAS,CAAC,6CAA6C,CAAC;MAC/E;IACJ;IACA,IAAI,IAAI,CAACb,QAAQ,EAAE;MACf,IAAIR,OAAO,CAACiB,QAAQ,CAAC4B,KAAK,CAAC,CAAC,GAAGlB,IAAI,EAAE;QACjC,MAAM,IAAIzB,QAAQ,CAACmB,SAAS,CAAC,6CAA6C,CAAC;MAC/E;MACA,OAAOM,IAAI;IACf;IACA,IAAIiB,CAAC,KAAKG,SAAS,IAAIY,KAAK,CAACf,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,EAAE;MACtC,OAAO,IAAI,CAACgB,eAAe,CAACjC,IAAI,CAAC;IACrC,CAAC,MACI;MACD,MAAMkC,KAAK,GAAG,EAAE;MAChB,OAAOjB,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACfjB,IAAI,GAAG,IAAI,CAACiC,eAAe,CAACjC,IAAI,CAAC;QACjCkC,KAAK,CAACC,IAAI,CAACnC,IAAI,CAAC;MACpB;MACA,OAAOkC,KAAK;IAChB;EACJ;EACAE,UAAUA,CAAA,EAAG;IACT,OAAOb,IAAI,CAACc,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAACrB,MAAM,CAAC,CAAC,CAACsB,QAAQ,CAAC,CAAC,GAAGjE,OAAO,CAACiB,QAAQ,CAAC4B,KAAK,CAAC,CAAC,CAACoB,QAAQ,CAAC,CAAC,CAAC;EACvF;EACAC,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAClC;EACAD,MAAMA,CAAA,EAAG;IACL,OAAOlE,WAAW,CAACoE,UAAU,CAACC,GAAG,CAACC,IAAI,IAAI;MACtC,OAAO,IAAI,CAACC,QAAQ,CAACD,IAAI,CAAC;IAC9B,CAAC,CAAC;EACN;EACAX,eAAeA,CAACa,KAAK,EAAEnE,QAAQ,EAAE;IAC7B,IAAIoE,EAAE;IACN,IAAID,KAAK,YAAYnD,IAAI,EAAE;MACvBmD,KAAK,GAAGzE,OAAO,CAACiB,QAAQ,CAACM,UAAU,CAACkD,KAAK,CAAC;IAC9C;IACA,IAAI9C,IAAI,GAAG8C,KAAK;IAChB,MAAME,SAAS,GAAGF,KAAK,CAACR,QAAQ,CAAC,CAAC;IAClC,IAAI3D,QAAQ,EAAE;MACVqB,IAAI,GAAGA,IAAI,CAACmB,OAAO,CAACxC,QAAQ,CAAC;IACjC;IACA,IAAI,CAAC,IAAI,CAACE,QAAQ,EAAE;MAChB,IAAImB,IAAI,CAACiD,WAAW,GAAG,CAAC,EAAE;QACtBjD,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAED,WAAW,EAAE,CAAC;UAAEnE,MAAM,EAAEkB,IAAI,CAAClB,MAAM,GAAG;QAAE,CAAC,CAAC;MAChE;IACJ;IACA,IAAI,CAACkB,IAAI,CAACP,OAAO,EAAE;MACf,MAAM,IAAIlB,QAAQ,CAACmB,SAAS,CAAC,uCAAuC,CAAC;IACzE;IACA,MAAMyD,QAAQ,GAAG9E,OAAO,CAACiB,QAAQ,CAAC8D,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC;MAAEC,KAAK,EAAE;IAAE,CAAC,CAAC;IAC1D,OAAO,IAAI,EAAE;MACT,MAAMC,IAAI,GAAGvD,IAAI,CAACsC,QAAQ,CAAC,CAAC,GAAGQ,KAAK,CAACR,QAAQ,CAAC,CAAC;MAC/C,IAAItC,IAAI,GAAGmD,QAAQ,EAAE;QACjB,MAAM,IAAI5E,QAAQ,CAACmB,SAAS,CAAE;AAC9C;AACA,oBAAoB,CAACqD,EAAE,GAAGpE,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAAC4D,QAAQ,CAAC,CAAC,MAAM,IAAI,IAAIQ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAK,mBAAkB,IAAI,CAACrE,MAAM,CAAC6D,QAAQ,CAAC,CAAE,kBAAiBvC,IAAI,CAACwD,MAAO,oBAAmBnF,OAAO,CAACiB,QAAQ,CAAC4B,KAAK,CAAC,CAAC,CAACqB,QAAQ,CAAC,CAAE,EAAC,CAAC;MAC5P;MACA,IAAI,EAAEvC,IAAI,CAACd,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC,IAC3BlB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACvE,KAAK,CAAC,CAACwE,MAAM,KAAK,EAAE,EAAE;QACvC1D,IAAI,GAAGA,IAAI,CAACqD,IAAI,CAAC;UAAEnD,MAAM,EAAE;QAAE,CAAC,CAAC;QAC/BF,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAExC,GAAG,EAAE,CAAC;UAAE1B,IAAI,EAAE,CAAC;UAAED,MAAM,EAAE,CAAC;UAAED,MAAM,EAAE;QAAE,CAAC,CAAC;QAC1D,IAAI,IAAI,CAAC6E,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE3D,IAAI,CAAC,EAAE;UAClC,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI,EAAE5D,IAAI,CAACU,GAAG,IAAI,IAAI,CAACzB,UAAU,CAAC,IAC9BjB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACxE,UAAU,CAAC,CAACyE,MAAM,KAAK,EAAE,IAC1C,EAAE,IAAI,CAAC3D,WAAW,CAACC,IAAI,CAAC,IAAI,IAAI,CAACb,SAAS,IACtCnB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACtE,SAAS,CAAC,CAACuE,MAAM,KAAK,CAAC,CAAC,EAAE;QAC/C1D,IAAI,GAAGA,IAAI,CAACqD,IAAI,CAAC;UAAEU,IAAI,EAAE;QAAE,CAAC,CAAC;QAC7B/D,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAElE,IAAI,EAAE,CAAC;UAAED,MAAM,EAAE,CAAC;UAAED,MAAM,EAAE;QAAE,CAAC,CAAC;QAClD,IAAI,IAAI,CAAC6E,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE3D,IAAI,CAAC,EAAE;UAClC,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI,EAAE,IAAI,CAAC7D,WAAW,CAACC,IAAI,CAAC,IAAI,IAAI,CAACb,SAAS,CAAC,IAC3CnB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACtE,SAAS,CAAC,CAACuE,MAAM,KAAK,CAAC,IACxC,EAAE1D,IAAI,CAACU,GAAG,IAAI,IAAI,CAACzB,UAAU,IACzBjB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACxE,UAAU,CAAC,CAACyE,MAAM,KAAK,EAAE,CAAC,EAAE;QACjD1D,IAAI,GAAGA,IAAI,CAACqD,IAAI,CAAC;UAAEU,IAAI,EAAE;QAAE,CAAC,CAAC;QAC7B/D,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAElE,IAAI,EAAE,CAAC;UAAED,MAAM,EAAE,CAAC;UAAED,MAAM,EAAE;QAAE,CAAC,CAAC;QAClD,IAAI,IAAI,CAAC6E,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE3D,IAAI,CAAC,EAAE;UAClC,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI,EAAE5D,IAAI,CAAChB,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC,IAAIhB,MAAM,CAACyF,IAAI,CAAC,IAAI,CAACzE,IAAI,CAAC,CAAC0E,MAAM,KAAK,EAAE,EAAE;QACnE,MAAMM,YAAY,GAAGhE,IAAI,CAAChB,IAAI,KAAK,EAAE,IAAIuE,IAAI,GAAG,QAAQ,GAAG,CAAC,GAAGvD,IAAI,CAAChB,IAAI,GAAG,CAAC;QAC5E,MAAMiF,cAAc,GAAGjE,IAAI,CAACjB,MAAM;QAClCiB,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAElE,IAAI,EAAEgF;QAAa,CAAC,CAAC;QACvChE,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAEnE,MAAM,EAAE,CAAC;UAAED,MAAM,EAAE;QAAE,CAAC,CAAC;QACzC,IAAI,IAAI,CAAC6E,eAAe,CAACK,YAAY,EAAEC,cAAc,EAAEjE,IAAI,CAAC,EAAE;UAC1D,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI,EAAE5D,IAAI,CAACjB,MAAM,IAAI,IAAI,CAACA,MAAM,CAAC,IAC7Bf,MAAM,CAACyF,IAAI,CAAC,IAAI,CAAC1E,MAAM,CAAC,CAAC2E,MAAM,KAAK,EAAE,EAAE;QACxC,MAAMO,cAAc,GAAGjE,IAAI,CAACjB,MAAM,KAAK,EAAE,IAAIwE,IAAI,GAAG,OAAO,GAAG,CAAC,GAAGvD,IAAI,CAACjB,MAAM,GAAG,CAAC;QACjF,MAAMiF,YAAY,GAAGhE,IAAI,CAAChB,IAAI,IAAIiF,cAAc,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;QAChEjE,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAEnE,MAAM,EAAEkF;QAAe,CAAC,CAAC;QAC3CjE,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAEpE,MAAM,EAAE;QAAE,CAAC,CAAC;QAC9B,IAAI,IAAI,CAAC6E,eAAe,CAACK,YAAY,EAAEC,cAAc,EAAEjE,IAAI,CAAC,EAAE;UAC1D,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI,EAAE5D,IAAI,CAAClB,MAAM,IAAI,IAAI,CAACA,MAAM,CAAC,IAC7Bd,MAAM,CAACyF,IAAI,CAAC,IAAI,CAAC3E,MAAM,CAAC,CAAC4E,MAAM,KAAK,EAAE,EAAE;QACxC,MAAMQ,cAAc,GAAGlE,IAAI,CAAClB,MAAM,KAAK,EAAE,IAAIyE,IAAI,GAAG,KAAK,GAAG,CAAC,GAAGvD,IAAI,CAAClB,MAAM,GAAG,CAAC;QAC/E,MAAMmF,cAAc,GAAGjE,IAAI,CAACjB,MAAM,IAAImF,cAAc,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;QACpE,MAAMF,YAAY,GAAGhE,IAAI,CAAChB,IAAI,IAAIiF,cAAc,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;QAChEjE,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAEpE,MAAM,EAAEoF;QAAe,CAAC,CAAC;QAC3C,IAAI,IAAI,CAACP,eAAe,CAACK,YAAY,EAAEC,cAAc,EAAEjE,IAAI,CAAC,EAAE;UAC1D,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA,IAAI5D,IAAI,CAACsC,QAAQ,CAAC,CAAC,KAAKU,SAAS,EAAE;QAC/B,MAAMkB,cAAc,GAAGlE,IAAI,CAAClB,MAAM,GAAG,CAAC;QACtC,MAAMmF,cAAc,GAAGjE,IAAI,CAACjB,MAAM,IAAImF,cAAc,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;QACpE,MAAMF,YAAY,GAAGhE,IAAI,CAAChB,IAAI,IAAIiF,cAAc,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;QAChEjE,IAAI,GAAGA,IAAI,CAACkD,GAAG,CAAC;UAAEpE,MAAM,EAAEoF;QAAe,CAAC,CAAC;QAC3C,IAAI,IAAI,CAACP,eAAe,CAACK,YAAY,EAAEC,cAAc,EAAEjE,IAAI,CAAC,EAAE;UAC1D,MAAM,CAAC4D,MAAM,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAAC9D,IAAI,CAAC;UACzDA,IAAI,GAAG6D,OAAO;UACd,IAAID,MAAM,EACN;QACR;QACA;MACJ;MACA;IACJ;IACA,OAAO5D,IAAI;EACf;EACA8D,oBAAoBA,CAAC9D,IAAI,EAAE;IACvB,IAAI+C,EAAE;IACN,IAAIkB,cAAc,EAAED,YAAY,EAAEG,YAAY,EAAEC,UAAU;IAC1D,IAAIC,iBAAiB,GAAGrE,IAAI;IAC5B,MAAMsE,cAAc,GAAG,EAAE,GAAG,EAAE;IAC9B,IAAIC,SAAS,GAAG,CAAC;IACjB,GAAG;MACC,IAAI,EAAEA,SAAS,GAAGD,cAAc,EAAE;QAC9B,MAAM,IAAI/F,QAAQ,CAACmB,SAAS,CAAE,yEAAwE,CAACqD,EAAE,GAAG/C,IAAI,CAACwE,KAAK,CAAC,CAAC,MAAM,IAAI,IAAIzB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG/C,IAAI,CAACsC,QAAQ,CAAC,CAAE,qCAAoC,CAAC;MACpN;MACA2B,cAAc,GAAGI,iBAAiB,CAACtF,MAAM,GAAG,CAAC;MAC7CiF,YAAY,GAAGK,iBAAiB,CAACrF,IAAI;MACrC,IAAIiF,cAAc,GAAG,CAAC,EAAE;QACpBA,cAAc,IAAI,EAAE;QACpBD,YAAY,GAAG,CAACA,YAAY,GAAG,EAAE,GAAG,CAAC,IAAI,EAAE;MAC/C;MACAK,iBAAiB,GAAGA,iBAAiB,CAACI,KAAK,CAAC;QAAE1F,MAAM,EAAE;MAAE,CAAC,CAAC;MAC1DoF,YAAY,GAAGE,iBAAiB,CAACtF,MAAM;MACvCqF,UAAU,GAAGC,iBAAiB,CAACrF,IAAI;IACvC,CAAC,QAAQiF,cAAc,KAAKE,YAAY,IAAIH,YAAY,KAAKI,UAAU;IACvE,MAAMM,iBAAiB,GAAGL,iBAAiB,CACtChB,IAAI,CAAC;MAAEtE,MAAM,EAAE;IAAE,CAAC,CAAC,CACnBmE,GAAG,CAAC;MAAEpE,MAAM,EAAE,CAAC;MAAEmE,WAAW,EAAE;IAAE,CAAC,CAAC;IACvC,MAAM0B,kBAAkB,GAAGD,iBAAiB,CAACD,KAAK,CAAC;MAAE3F,MAAM,EAAE;IAAE,CAAC,CAAC;IACjE,IAAIkB,IAAI,CAACd,KAAK,GAAG,CAAC,IAAI,IAAI,CAACA,KAAK,IAC5Bc,IAAI,CAACU,GAAG,IAAI,IAAI,CAACzB,UAAU,IAC3B,IAAI,CAACc,WAAW,CAACC,IAAI,CAAC,IAAI,IAAI,CAACb,SAAS,EAAE;MAC1C,OAAO,CACH,IAAI,CAACyF,wBAAwB,CAACD,kBAAkB,EAAED,iBAAiB,CAAC,EACpEA,iBAAiB,CACpB;IACL;IACA,OAAO,CAAC,KAAK,EAAEA,iBAAiB,CAAC;EACrC;EACAE,wBAAwBA,CAACD,kBAAkB,EAAED,iBAAiB,EAAE;IAC5D,MAAMG,cAAc,GAAG,CAACF,kBAAkB,CAAC5F,MAAM,GAAG,CAAC,IAAI,EAAE;IAC3D,MAAM+F,YAAY,GAAG,CAACH,kBAAkB,CAAC3F,IAAI,IAAI6F,cAAc,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;IACpF,MAAME,aAAa,GAAGL,iBAAiB,CAAC1F,IAAI,GAAG8F,YAAY,GAAG,CAAC;IAC/D,MAAME,UAAU,GAAGH,cAAc,KAAK,CAAC,IAAIH,iBAAiB,CAAC3F,MAAM,KAAK,CAAC;IACzE,IAAIgG,aAAa,KAAK,CAAC,IAAIC,UAAU,EAAE;MACnC,OAAOF,YAAY,IAAI,IAAI,CAAC9F,IAAI;IACpC,CAAC,MACI,IAAI+F,aAAa,KAAK,CAAC,EAAE;MAC1B,OAAQD,YAAY,IAAI,IAAI,CAAC9F,IAAI,IAC7B,IAAI,CAACiG,kCAAkC,CAACJ,cAAc,EAAEH,iBAAiB,CAAC3F,MAAM,CAAC;IACzF,CAAC,MACI;MACD,OAAO,IAAI,CAACmG,iCAAiC,CAACJ,YAAY,EAAED,cAAc,EAAEH,iBAAiB,CAAC1F,IAAI,EAAE0F,iBAAiB,CAAC3F,MAAM,CAAC;IACjI;EACJ;EACAkG,kCAAkCA,CAACE,WAAW,EAAEC,SAAS,EAAE;IACvD,KAAK,IAAIrG,MAAM,GAAGoG,WAAW,EAAEpG,MAAM,GAAGqG,SAAS,EAAE,EAAErG,MAAM,EAAE;MACzD,IAAIA,MAAM,IAAI,IAAI,CAACA,MAAM,EACrB,OAAO,IAAI;IACnB;IACA,OAAOqG,SAAS,IAAI,IAAI,CAACrG,MAAM,IAAI,CAAC,IAAI,IAAI,CAACD,MAAM;EACvD;EACAoG,iCAAiCA,CAACG,SAAS,EAAEF,WAAW,EAAEG,OAAO,EAAEF,SAAS,EAAE;IAC1E,IAAIC,SAAS,IAAIC,OAAO,EAAE;MACtB,MAAM,IAAI/G,QAAQ,CAACmB,SAAS,CAAE,qFAAoF2F,SAAU,gCAA+BC,OAAQ,GAAE,CAAC;IAC1K;IACA,MAAMC,oBAAoB,GAAGC,KAAK,CAACC,IAAI,CAAC;MAAE/B,MAAM,EAAE,EAAE,GAAGyB;IAAY,CAAC,EAAE,CAACO,CAAC,EAAEC,CAAC,KAAKR,WAAW,GAAGQ,CAAC,CAAC;IAChG,MAAMC,mBAAmB,GAAGJ,KAAK,CAACC,IAAI,CAAC;MAAE/B,MAAM,EAAE0B;IAAU,CAAC,EAAE,CAACM,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC;IAC1E,MAAME,qBAAqB,GAAGL,KAAK,CAACC,IAAI,CAAC;MAAE/B,MAAM,EAAE;IAAG,CAAC,EAAE,CAACgC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC;IACrE,MAAMG,WAAW,GAAIC,OAAO,IAAK;MAC7B,IAAIA,OAAO,KAAKV,SAAS,EAAE;QACvB,OAAOE,oBAAoB;MAC/B,CAAC,MACI,IAAIQ,OAAO,KAAKT,OAAO,EAAE;QAC1B,OAAOM,mBAAmB;MAC9B,CAAC,MACI;QACD,OAAOC,qBAAqB;MAChC;IACJ,CAAC;IACD,KAAK,IAAI7G,IAAI,GAAGqG,SAAS,EAAErG,IAAI,IAAIsG,OAAO,EAAE,EAAEtG,IAAI,EAAE;MAChD,IAAI,EAAEA,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC,EACpB;MACJ,MAAMgH,UAAU,GAAGF,WAAW,CAAC9G,IAAI,CAAC;MACpC,KAAK,MAAMD,MAAM,IAAIiH,UAAU,EAAE;QAC7B,IAAIjH,MAAM,IAAI,IAAI,CAACA,MAAM,EACrB,OAAO,IAAI;MACnB;IACJ;IACA,OAAOuG,OAAO,IAAI,IAAI,CAACtG,IAAI,IAAIoG,SAAS,IAAI,IAAI,CAACrG,MAAM,IAAI,CAAC,IAAI,IAAI,CAACD,MAAM;EAC/E;EACA6E,eAAeA,CAACK,YAAY,EAAEC,cAAc,EAAEgC,UAAU,EAAE;IACtD,MAAM7B,UAAU,GAAG6B,UAAU,CAACjH,IAAI;IAClC,MAAMmF,YAAY,GAAG8B,UAAU,CAAClH,MAAM;IACtC,MAAMmH,cAAc,GAAGlC,YAAY,GAAG,EAAE,GAAGI,UAAU;IACrD,MAAM+B,gBAAgB,GAAGlC,cAAc,GAAG,EAAE,GAAGE,YAAY;IAC3D,OAAO+B,cAAc,IAAIC,gBAAgB;EAC7C;EACAtD,QAAQA,CAACD,IAAI,EAAE;IACX,IAAI,IAAI,CAACwD,OAAO,CAACxD,IAAI,CAAC,EAAE;MACpB,OAAO,GAAG;IACd;IACA,MAAMyD,GAAG,GAAG,EAAE;IACd,KAAK,MAAMC,IAAI,IAAI,IAAI,CAAC1D,IAAI,CAAC,EAAE;MAC3ByD,GAAG,CAAClE,IAAI,CAACmE,IAAI,CAAC;IAClB;IACA,OAAOD,GAAG,CAAC5D,IAAI,CAAC,GAAG,CAAC;EACxB;EACA2D,OAAOA,CAACxD,IAAI,EAAE;IACV,MAAM2D,WAAW,GAAGjI,WAAW,CAACkI,WAAW,CAAC5D,IAAI,CAAC;IACjD,MAAM6D,GAAG,GAAGF,WAAW,CAAC,CAAC,CAAC;IAC1B,MAAMG,IAAI,GAAG9D,IAAI,KAAKtE,WAAW,CAACqI,cAAc,CAACC,WAAW,GAAGL,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAC;IAClG,KAAK,IAAItF,CAAC,GAAGwF,GAAG,EAAEI,CAAC,GAAGH,IAAI,EAAEzF,CAAC,GAAG4F,CAAC,EAAE5F,CAAC,EAAE,EAAE;MACpC,IAAI,EAAEA,CAAC,IAAI,IAAI,CAAC2B,IAAI,CAAC,CAAC,EAAE;QACpB,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA/C,MAAMA,CAACnB,MAAM,EAAE;IACX,IAAIqE,EAAE;IACNrE,MAAM,GAAGA,MAAM,CAACoI,WAAW,CAAC,CAAC;IAC7B,IAAI9I,MAAM,CAACyF,IAAI,CAACnF,WAAW,CAACyI,OAAO,CAAC,CAACC,QAAQ,CAACtI,MAAM,CAAC,EAAE;MACnDA,MAAM,GAAGJ,WAAW,CAACyI,OAAO,CAACrI,MAAM,CAAC;IACxC;IACAA,MAAM,GAAGA,MAAM,CAACuI,OAAO,CAAC,cAAc,EAAGC,KAAK,IAAK;MAC/C,IAAIlJ,MAAM,CAACyF,IAAI,CAACnF,WAAW,CAAC6I,OAAO,CAAC,CAACH,QAAQ,CAACE,KAAK,CAAC,EAAE;QAClD,OAAO5I,WAAW,CAAC6I,OAAO,CAACD,KAAK,CAAC,CAAC3E,QAAQ,CAAC,CAAC;MAChD;MACA,MAAM,IAAIhE,QAAQ,CAACmB,SAAS,CAAE,kBAAiBwH,KAAM,EAAC,CAAC;IAC3D,CAAC,CAAC;IACF,MAAME,KAAK,GAAG1I,MAAM,CAAC2I,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;IACxC,IAAIF,KAAK,CAAC1D,MAAM,GAAGpF,WAAW,CAACiJ,cAAc,GAAG,CAAC,EAAE;MAC/C,MAAM,IAAIhJ,QAAQ,CAACmB,SAAS,CAAC,gBAAgB,CAAC;IAClD;IACA,IAAI0H,KAAK,CAAC1D,MAAM,GAAGpF,WAAW,CAACiJ,cAAc,EAAE;MAC3C,MAAM,IAAIhJ,QAAQ,CAACmB,SAAS,CAAC,iBAAiB,CAAC;IACnD;IACA,MAAM8H,QAAQ,GAAGJ,KAAK,CAAC1D,MAAM;IAC7B,KAAK,MAAMd,IAAI,IAAItE,WAAW,CAACoE,UAAU,EAAE;MACvC,MAAMzB,CAAC,GAAG3C,WAAW,CAACoE,UAAU,CAAC+E,OAAO,CAAC7E,IAAI,CAAC;MAC9C,MAAM8E,GAAG,GAAG,CAAC3E,EAAE,GAAGqE,KAAK,CAACnG,CAAC,IAAI3C,WAAW,CAACiJ,cAAc,GAAGC,QAAQ,CAAC,CAAC,MAAM,IAAI,IAAIzE,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGzE,WAAW,CAACqJ,cAAc,CAAC/E,IAAI,CAAC;MACvI,IAAI,CAACgF,WAAW,CAACF,GAAG,EAAE9E,IAAI,CAAC;IAC/B;EACJ;EACAgF,WAAWA,CAACzJ,KAAK,EAAEyE,IAAI,EAAE;IACrB,MAAMiF,OAAO,GAAG,IAAI,CAACjF,IAAI,CAAC;IAC1B,IAAIkF,OAAO;IACX,MAAMvB,WAAW,GAAGjI,WAAW,CAACkI,WAAW,CAAC5D,IAAI,CAAC;IACjD,MAAM6D,GAAG,GAAGF,WAAW,CAAC,CAAC,CAAC;IAC1B,MAAMG,IAAI,GAAGH,WAAW,CAAC,CAAC,CAAC;IAC3B,MAAMwB,MAAM,GAAG5J,KAAK,CAACmJ,KAAK,CAAC,GAAG,CAAC;IAC/BS,MAAM,CAACC,OAAO,CAACC,KAAK,IAAI;MACpB,MAAMC,aAAa,GAAGD,KAAK,CAACR,OAAO,CAAC,GAAG,CAAC;MACxC,IAAIS,aAAa,KAAK,CAAC,CAAC,IAAIA,aAAa,KAAK,CAAC,EAAE;QAC7C,MAAM,IAAI3J,QAAQ,CAACmB,SAAS,CAAE,UAASuI,KAAM,sCAAqC,CAAC;MACvF;IACJ,CAAC,CAAC;IACF9J,KAAK,GAAGA,KAAK,CAAC8I,OAAO,CAAC3I,WAAW,CAAC6J,YAAY,EAAG,GAAE1B,GAAI,IAAGC,IAAK,EAAC,CAAC;IACjE,MAAM0B,SAAS,GAAGjK,KAAK,CAACmJ,KAAK,CAAC,GAAG,CAAC;IAClC,KAAK,MAAMe,KAAK,IAAID,SAAS,EAAE;MAC3B,MAAME,KAAK,GAAG,CAAC,GAAGD,KAAK,CAACE,QAAQ,CAACjK,WAAW,CAACkK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1D,IAAI,CAACF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,MAAMlH,SAAS,EAAE;QACxE,MAAM,GAAGqH,MAAM,EAAEC,MAAM,EAAEC,KAAK,CAAC,GAAGL,KAAK;QACvC,IAAIM,KAAK,GAAGC,QAAQ,CAACJ,MAAM,EAAE,EAAE,CAAC;QAChC,IAAIK,KAAK,GAAGJ,MAAM,KAAKtH,SAAS,GAAGyH,QAAQ,CAACH,MAAM,EAAE,EAAE,CAAC,GAAGtH,SAAS;QACnE,MAAM2H,cAAc,GAAGJ,KAAK,KAAKvH,SAAS;QAC1C,MAAM4H,IAAI,GAAGH,QAAQ,CAACF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAGA,KAAK,GAAG,GAAG,EAAE,EAAE,CAAC;QAC3E,IAAIK,IAAI,KAAK,CAAC,EAAE;UACZ,MAAM,IAAIzK,QAAQ,CAACmB,SAAS,CAAE,UAASkD,IAAK,sBAAqB,CAAC;QACtE;QACA,IAAIkG,KAAK,KAAK1H,SAAS,IAAIwH,KAAK,GAAGE,KAAK,EAAE;UACtC,MAAM,IAAIvK,QAAQ,CAACmB,SAAS,CAAE,UAASkD,IAAK,wBAAuB,CAAC;QACxE;QACA,MAAMqG,YAAY,GAAGL,KAAK,GAAGnC,GAAG,IAC3BqC,KAAK,KAAK1H,SAAS,IAAI0H,KAAK,GAAGpC,IAAK,IACpCoC,KAAK,KAAK1H,SAAS,IAAIwH,KAAK,GAAGlC,IAAK;QACzC,IAAIuC,YAAY,EAAE;UACd,MAAM,IAAI1K,QAAQ,CAACmB,SAAS,CAAE,gBAAevB,KAAM,mBAAkB,CAAC;QAC1E;QACAyK,KAAK,GAAGrH,IAAI,CAAC2H,GAAG,CAAC3H,IAAI,CAACc,GAAG,CAACoE,GAAG,EAAE,CAAC,CAAClF,IAAI,CAACI,GAAG,CAACiH,KAAK,CAAC,CAAC,EAAElC,IAAI,CAAC;QACxD,IAAIoC,KAAK,KAAK1H,SAAS,EAAE;UACrB0H,KAAK,GAAGvH,IAAI,CAAC2H,GAAG,CAACxC,IAAI,EAAE,CAAC,CAACnF,IAAI,CAACI,GAAG,CAACmH,KAAK,CAAC,CAAC;QAC7C,CAAC,MACI;UACDA,KAAK,GAAGC,cAAc,GAAGrC,IAAI,GAAGkC,KAAK;QACzC;QACAd,OAAO,GAAGc,KAAK;QACf,GAAG;UACCf,OAAO,CAACC,OAAO,CAAC,GAAG,IAAI;UACvBA,OAAO,IAAIkB,IAAI;QACnB,CAAC,QAAQlB,OAAO,IAAIgB,KAAK;QACzB,IAAIlG,IAAI,KAAK,WAAW,EAAE;UACtB,IAAI,CAACiF,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAACA,OAAO,CAAC,CAAC,CAAC,EAC3BA,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC;UAC3B,OAAOA,OAAO,CAAC,CAAC,CAAC;QACrB;MACJ,CAAC,MACI;QACD,MAAM,IAAItJ,QAAQ,CAACmB,SAAS,CAAE,UAASkD,IAAK,oBAAmB,CAAC;MACpE;IACJ;EACJ;AACJ;AACA1E,OAAO,CAACE,QAAQ,GAAGA,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}